@startuml
' declate title
title 6.2.5. Acknowledgement of Settlement Transfer (updateSettlementById)
autonumber

' declare actors
actor "Hub Employee" as OPERATOR
boundary "Settlement Service API" as SSAPI
entity "Settlement DAO" as SETTLE_DAO
database "Central Store" as DB

box "Central HUB" #lightpink
    participant OPERATOR
end box

box "Settlement Service" #lightgreen
    participant SSAPI
    participant SETTLE_DAO
end box

box "Central Services" #lightyellow
    participant DB
end box

' start flow
group Acknowledgement of Settlement Transfer
    activate OPERATOR
    note right of OPERATOR #yellow
        {
            "participants": [
                {
                    "id": 1
                    "accounts" : [
                        {
                            "id": 1,
                            "state": "PENDING_SETTLEMENT",
                            "reason": <string>
                        },
                        {
                            "id": 2,
                            "state": "SETTLED",
                            "reason": <string>
                        }
                    ]
                },
                {
                    "id": 2
                    "accounts" : [
                        {
                            "id": 3,
                            "state": "NOT_SETTLED",
                            "reason": <string>
                        }
                    ]
                }
            ]
        }
    end note

    OPERATOR -> SSAPI: PUT - /settlement/{id}
    activate SSAPI
    SSAPI -> SETTLE_DAO: Retrieve full information for settlement\n<color #FF0000><b>Error code:</b> 2001</color>
    activate SETTLE_DAO
    SETTLE_DAO -> DB: Select from DB
    activate DB
    hnote over DB #lightyellow
        SELECT s.settlementId, ssc.settlementStateId, 
               ssc.reason, ssc.createdDate
        FROM **settlement** s
        JOIN **settlementStateChange** ssc
        ON ssc.settlementStateChangeId = s.currentStateChangeId
        WHERE s.settlementId = {id}
    end hnote
    SETTLE_DAO <-- DB: Return data
    deactivate DB
    SSAPI <-- SETTLE_DAO: Return **settlementData**
    deactivate SETTLE_DAO

    SSAPI -> SETTLE_DAO: Retrive full information for settlement accounts\n<color #FF0000><b>Error code:</b> 2001</color>
    activate SETTLE_DAO
    SETTLE_DAO -> DB: Select from DB
    activate DB
    hnote over DB #lightyellow
        SELECT pc.participantId, spc.participantCurrencyId, 
               spcsc.settlementStateId, spcsc.reason,
               spcsc.createdDate, spc.netAmount, pc.currencyId, 
               spc.settlementParticipantCurrencyId AS <color #0000FF>key</color>
        FROM **settlementParticipantCurrency** spc
        JOIN **settlementParticipantCurrencyStateChange** spcsc
        ON spcsc.settlementParticipantCurrencyStateChangeId = 
           spc.currentStateChangeId
        JOIN **participantCurrency** pc
        ON pc.participantCurrencyId = spc.participantCurrencyId
        WHERE spc.settlementId = {id}
    end hnote
    SETTLE_DAO <-- DB: Return data
    deactivate DB
    SSAPI <-- SETTLE_DAO: Return **settlementAccountsList**
    deactivate SETTLE_DAO

    SSAPI -> SETTLE_DAO: Retrive full information for settlement windows\n<color #FF0000><b>Error code:</b> 2001</color>
    activate SETTLE_DAO
    SETTLE_DAO -> DB: Select from DB
    activate DB
    hnote over DB #lightyellow
        SELECT ssw.settlementWindowId, sswsc.settlementWindowStateId,
               sswsc.reason, sswsc.createdDate
        FROM **settlementSettlementWindow** ssw
        JOIN **settlementWindow** sw
        ON sw.settlementWindow = ssw.settlementWindowId
        JOIN **settlementWindowStateChange** swsc
        ON swsc.settlementWindowStateChangeId = sw.currentStateChangeId
        WHERE ssw.settlementId = {id}
    end hnote
    SETTLE_DAO <-- DB: Return data
    deactivate DB
    SSAPI <-- SETTLE_DAO: Return **windowsList**
    deactivate SETTLE_DAO

    SSAPI -> SETTLE_DAO: Retrive full information for settlement windows accounts\n<color #FF0000><b>Error code:</b> 2001</color>
    activate SETTLE_DAO
    SETTLE_DAO -> DB: Select from DB
    activate DB
    hnote over DB #lightyellow
        SELECT DISTINCT settlementWindowId, participantCurrencyId
        FROM **settlementTransferParticipant**
        WHERE settlementId = {id}
    end hnote
    SETTLE_DAO <-- DB: Return data
    deactivate DB
    SSAPI <-- SETTLE_DAO: Return **windowsAccountsList**
    deactivate SETTLE_DAO

    note right of SSAPI #lightblue
        All objects below are done for the purposes of the syncronous request.
        If at same point Node process memory limit is reached we may decide to:
        A. Limit the amount of transfers per window and windows per settlement or
        B. Move to asyncronous processing where we don't need these objects
    end note
    note right of SSAPI #lightgray
        Available raw datasets from DB:
        **settlementData** contains information about settlement and its current state/reason
        **settlementAccountsList** holds information about all accounts and their current state/reason
        **windowsList** has information about all windows and their current state/reason
        **windowsAccountsList** has information about all accounts and windows

        Local variables and objects:
        **settlementAccounts**: { // (derived from <color 0000FF>settlementAccountsList</color>)
            pendingSettlementCount: <integer>, // count of accounts in PENDING_SETTLEMENT state
            settledCount: <integer>, // count of accounts in SETTLED state
            notSettledCount: <integer> // count of accounts in NOT_SETTLED state
        }
        **settlementAccountsInit** copy of previous object to be preserved for comparission at the end
        ' **allParticipants**: { // same as participants response object with initial data & key (derived from <color 0000FF>settlementAccountsList</color>)
        '     participantId_key: { // number used to access the object in map-like style
        '         id: participantId,
        '         accounts: {
        '             participantCurrencyId_key: { // number used to access the object in map-like style
        '                 id: participantCurrencyId,
        '                 state: settlementStateId,
        '                 reason: reason,
        '                 createdDate: createdDate,
        '                 netSettlementAmount: {
        '                     amount: netAmount,
        '                     currency: currencyId
        '                 }
        '             }
        '         }
        '     }
        ' }
        **allAccounts**: { // same as previous but accessed by account id (derived from <color 0000FF>settlementAccountsList</color>)
            participantCurrencyId_key: { // number used to access the object in map-like style
                id: participantCurrencyId,
                state: settlementStateId,
                reason: reason,
                createdDate: createdDate,
                netSettlementAmount: {
                    amount: netAmount,
                    currency: currencyId
                },
                participantId: participantId, // could be used to reconstruct allParticipants
                key: <color 0000FF>key</color> // will be used to insert new state for settlementParticipantCurrency
            }
        }
        **allWindows**: { // same as settlementWindows response object with initial data (derived from <color 0000FF>windowsList</color>)
            settlementWindowId_key: { // number used to access the object in map-like style
                id: settlementWindowId, // same as key value
                state: settlementWindowStateId, 
                reason: reason, 
                createdDate: createdDate
            }
        }
        **windowsAccounts**: {
            settlementWindowId_key: { // number used to access the object in map-like style
                id: settlementWindowId // same as key value
                pendingSettlementCount: <integer>, // count of accounts in PENDING_SETTLEMENT state
                settledCount: <integer>, // count of accounts in SETTLED state
                notSettledCount: <integer> // count of accounts in NOT_SETTLED state
            }
        }
        **windowsAccountsInit** copy of previous object to be preserved for comparission at the end
        **accountsWindows**: {
            participantCurrencyId_key: { // number used to access the object in map-like style
                id: participantCurrencyId, // same as key value
                windows: [] // array of windows to which the account settlement spans
            }
        }
        let **transactionTimestamp** = now()
    end note
    |||
    SSAPI -> SSAPI: <color FF0000>**Acquire DB lock**</color> on settlementParticipantCurrencyStateChange,\nsettlementWindowStateChange and settlementStateChange
    |||
    SSAPI -> SSAPI: Declare and initialize variables
    note right of SSAPI #lightgray
        let settlementAccounts = {
            pendingSettlementAccounts: 0,
            settledAccounts: 0,
            notSettledAccounts: 0,
        }
        ' let allParticipants = {} // declare sparse array
        let allAccounts = {} // declare sparse array
        let pid // participantId
        let aid // accountId (participantCurrencyId)
        let state
    end note

    loop settlementAccountsList as record
        SSAPI -> SSAPI: Populate **allAccounts** 
        ' and **allParticipants**
        note right of SSAPI #lightgray
            pid = record.participantId
            aid = record.participantCurrencyId
            state = record.settlementStateId

            allAccounts[aid] = {
                id: aid,
                state,
                reason: record.reason,
                createDate: record.createdDate,
                netSettlementAmount: {
                    amount: record.netAmount,
                    currency: record.currencyId
                },
                key
            }
            ' allParticipants[pid] = allParticipants[pid] ? allParticipants[pid] : {id: pid, accounts: {}}
            ' allParticipants[pid].accounts[aid] = allAccounts[aid]
        end note

        SSAPI -> SSAPI: Populate **settlementAccounts**
        alt state == 'PENDING_SETTLEMENT'
            note right of SSAPI #lightgray
                settlementAccounts.pendingSettlementCount++
            end note
        else state == 'SETTLED'
            note right of SSAPI #lightgray
                settlementAccounts.settledCount++
            end note
        else state == 'NOT_SETTLED'
            note right of SSAPI #lightgray
                settlementAccounts.notSettledCount++
            end note
        end
    end
    SSAPI -> SSAPI: Make a copy of settlementAccounts into **settlementAccountsInit**
    note right of SSAPI #lightgray
        settlementAccountsInit = Object.assign({}, settlementAccounts)
    end note
    |||
    SSAPI -> SSAPI: Declare and populate **allWindows**
    note right of SSAPI #lightgray
        let allWindows = {} // declare sparse array
        let wid // settlementWindowId
    end note
    loop windowsList as record
        note right of SSAPI #lightgray
            wid = record.settlementWindowId
            state = record.settlementWindowStateId

            allWindows[wid] = {
                id: wid,
                state,
                reason: record.reason,
                createDate: record.createdDate
            }
        end note
    end 
    |||
    SSAPI -> SSAPI: Declare and populate **accountsWindows** and **windowsAccounts**
    note right of SSAPI #lightgray
        let accountsWindows = {} // declare sparse array
        let windowsAccounts = {} // declare sparse array
    end note
    loop windowsAccountsList as record
        note right of SSAPI #lightgray
            wid = record.settlementWindowId
            aid = record.participantCurrencyId
            state = allAccounts[aid]

            accountsWindows[aid] = accountsWindows[aid] ? accountsWindows[aid] : {
                id: aid,
                windows: []
            }
            accountsWindows[aid].windows.push(wid)

            windowsAccounts[wid] = windowsAccounts[wid] ? windowsAccounts[wid] : {
                id: wid, 
                pendingSettlementCount: 0,
                settledCount: 0,
                notSettledCount: 0
            }
        end note
        alt state == 'PENDING_SETTLEMENT'
            note right of SSAPI #lightgray
                windowsAccounts[wid].pendingSettlementCount++
            end note
        else state == 'SETTLED'
            note right of SSAPI #lightgray
                windowsAccounts[wid].settledCount++
            end note
        else state == 'NOT_SETTLED'
            note right of SSAPI #lightgray
                windowsAccounts[wid].notSettledCount++
            end note
        end
    end
    SSAPI -> SSAPI: Make a copy of windowsAccounts into **windowsAccountsInit**
    note right of SSAPI #lightgray
        windowsAccountsInit = Object.assign({}, windowsAccounts)
    end note 
    |||
    note right of SSAPI #lightgray
        Available objects after the setup:
        **settlementAccounts** is used for tracing settlement state and state transition allowance
        ' **allParticipants** is used for tracing participant/account state and state transition
        **allAccounts** is helper object, same as previous, providing direct access to account by id
        **allWindows** has window information for all windows in the settlement
        **windowsAccounts** is used for tracing settlement window state and state transition allowance
        **accountsWindows** is helper object to show the list of windows to which settlement account spans

        Now we are ready to process the **payload**:
        **participants** = [] // part of the response object that lists the affected participants and respective accounts
        **affectedWindows** = [] // array of the affected windows
        **settlementParticipantCurrencyStateChange** = [] // array to collect inserts to the table
        **processedAccounts** = [] // array to log processed accounts and restrict subsequent processing
        let **pi** // declare participant index
        let **ai** // declare account index
        let **participant** -- declare pointer to current participant in the //response object//
        let **participantPayload** -- declare pointer to current participant in the //payload object//
        let **accountPayload** -- declare pointer to current account in the //payload object//
    end note
    |||
    loop let p IN payload.participants
        SSAPI -> SSAPI: Loop payload for each **participantPayload**
        note right of SSAPI #lightgray
            participantPayload = payload.participants[p]
            participants.push({id: participantPayload.id, accounts: []})
            pi = participants.length - 1
            participant = participants[pi]
        end note

        loop let a IN participantPayload.accounts
            SSAPI -> SSAPI: Loop payload for each **accountPayload**
            note right of SSAPI #lightgray
                accountPayload = participantPayload.accounts[a]
            end note
            alt allAccounts[accountPayload.id] == undefined
                SSAPI -> SSAPI: If the account doesn't match the settlement
                note right of SSAPI #lightgray
                    participant.accounts.push({
                        id: accountPayload.id,
                        errorInformation: {
                            errorCode: <integer>,
                            errorDescription: 'Account not found'
                        }
                    })
                end note
            else processedAccounts.indexOf(accountPayload.id) > -1
                SSAPI -> SSAPI: If the account has been previosly processed (duplicated in the payload)
                note right of SSAPI #lightgray
                    participant.accounts.push({
                        id: accountPayload.id,
                        state: allAccounts[accountPayload.id].state,
                        reason: allAccounts[accountPayload.id].reason,
                        createdDate: allAccounts[accountPayload.id].createdDate,
                        netSettlementAmount: allAccounts[accountPayload.id].netSettlementAmount
                        errorInformation: {
                            errorCode: <integer>,
                            errorDescription: 'Account already processed once'
                        }
                    })
                end note
            else allAccounts[account.id].state == accountPayload.state // allowed
                SSAPI -> SSAPI: All same-state reason insert is allowed (state preserved)
                note right of SSAPI #lightgray
                    processedAccounts.push(accountPayload.id)
                    participant.accounts.push({
                        id: accountPayload.id,
                        state: accountPayload.state,
                        reason: accountPayload.reason,
                        createdDate: transactionTimestamp,
                        netSettlementAmount: allAccounts[accountPayload.id].netSettlementAmount
                    })
                    settlementParticipantCurrencyStateChange.push({
                        settlementParticipantCurrencyId: allAccounts[accountPayload.id].key,
                        settlementStateId: accountPayload.state,
                        reason: accountPayload.reason
                    })
                    allAccounts[accountPayload.id].reason = accountPayload.reason
                    allAccounts[accountPayload.id].createdDate = currentTimestamp
                    ' allParticipants[participantPayload.id].accounts[accountPayload.id].reason = accountPayload.reason
                    ' allParticipants[participantPayload.id].accounts[accountPayload.id].createdDate = currentTimestamp
                end note
            else allAccounts[account.id].state == 'PENDING_SETTLEMENT' && accountPayload.state == 'SETTLED' // allowed
                SSAPI -> SSAPI: True settlement acknowledgement
                note right of SSAPI #lightgray
                    processedAccounts.push(accountPayload.id)
                    participant.accounts.push({
                        id: accountPayload.id,
                        state: accountPayload.state,
                        reason: accountPayload.reason,
                        createdDate: transactionTimestamp,
                        netSettlementAmount: allAccounts[accountPayload.id].netSettlementAmount
                    })
                    settlementParticipantCurrencyStateChange.push({
                        settlementParticipantCurrencyId: allAccounts[accountPayload.id].key,
                        settlementStateId: accountPayload.state,
                        reason: accountPayload.reason
                    })
                    settlementAccounts.pendingSettlementCount--
                    settlementAccounts.settledCount++
                    allAccounts[accountPayload.id].state = accountPayload.state
                    allAccounts[accountPayload.id].reason = accountPayload.reason
                    allAccounts[accountPayload.id].createdDate = currentTimestamp
                    ' allParticipants[participantPayload.id].accounts[accountPayload.id].state = accountPayload.state
                    ' allParticipants[participantPayload.id].accounts[accountPayload.id].reason = accountPayload.reason
                    ' allParticipants[participantPayload.id].accounts[accountPayload.id].createdDate = currentTimestamp
                    let settlementWindowId
                end note
                loop let aw IN accountsWindows[accountPayload.id].windows
                    note right of SSAPI #lightgray
                        settlementWindowId = accountsWindows[accountPayload.id].windows[aw]
                        windowsAccounts[settlementWindowId].pendingSettlementCount--
                        windowsAccounts[settlementWindowId].settledCount++

                        if (affectedWindows.indexOf(settlementWindowId) < 0) {
                            affectedWindows.push(settlementWindowId)
                        }
                    end note
                end
            else
                SSAPI -> SSAPI: All other state transitions are not permitted
                note right of SSAPI #lightgray
                    participant.accounts.push({
                        id: accountPayload.id,
                        state: allAccounts[accountPayload.id].state,
                        reason: allAccounts[accountPayload.id].reason,
                        createdDate: allAccounts[accountPayload.id].createdDate,
                        netSettlementAmount: allAccounts[accountPayload.id].netSettlementAmount
                        errorInformation: {
                            errorCode: <integer>,
                            errorDescription: 'State change not allowed'
                        }
                    })
                end note
            end
        end
    end
    group <color #blue>DB TRANSACTION</color>
        group Bulk insert settlementParticipantCurrencyStateChange
            SSAPI -> SETTLE_DAO: Change settlement participant currency states\n<color #FF0000><b>Error code:</b> 2001</color>
            activate SETTLE_DAO
            SETTLE_DAO -> DB: Insert settlementParticipantCurrencyStateChange
            activate DB
            hnote over DB #lightyellow
                settlementParticipantCurrencyStateChange
            end hnote
            SETTLE_DAO <-- DB: Return **settlementParticipantCurrencyStateChangeIdList**
            deactivate DB

            SETTLE_DAO -> SETTLE_DAO: Merge settlementParticipantCurrencyStateChangeIdList\nto settlementParticipantCurrencyIdList in order to\nissue the following update in one knex command

            SETTLE_DAO -> DB: Update pointers to current state change ids
            activate DB
            hnote over DB #lightyellow
                UPDATE **settlementParticipantCurrency**
                SET currentStateChangeId = 
                    {settlementParticipantCurrencyStateChangeIdList}
                WHERE settlementParticipantCurrencyId =
                      {settlementParticipantCurrencyStateChange
                      .settlementParticipantCurrencyIdList}
            end hnote
            deactivate DB

            deactivate SETTLE_DAO
        end
        group Prepare and insert settlementWindowStateChange
            note right of SSAPI #lightgray
                let settlementWindowStateChange = []
                let settlementWindows = [] // response object
                let windowAccountsInit
                let windowAccounts
                let windowState
            end note

            loop let aw IN affectedWindows
                note right of SSAPI #lightgray
                    windowAccountsInit = windowAccountsInit[affectedWindows[aw]]
                    windowAccounts = windowsAccounts[affectedWindows[aw]]
                end note
                opt windowAccounts.pendingSettlementCount != windowAccountsInit.pendingSettlementCount\n|| windowAccounts.settledCount != windowAccountsInit.settledCount
                    opt windowAccounts.pendingSettlementCount == 0\n&& windowAccounts.notSettledCount == 0\n&& windowAccounts.settledCound > 0
                        note right of SSAPI #lightgray
                            allWindows[affectedWindows[aw]].state = 'SETTLED'
                            allWindows[affectedWindows[aw]].reason = 'All setlement accounts are settled'
                            allWindows[affectedWindows[aw]].createdDate = currentTimestamp
                            settlementWindowStateChange.push(allWindows[affectedWindows[aw]])
                        end note
                    end
                    note right of SSAPI #lightgray
                        settlementWindows.push(allWindows[affectedWindows[aw]])
                    end note
                end
            end

            SSAPI -> SETTLE_DAO: Change settlement windows states\n<color #FF0000><b>Error code:</b> 2001</color>
            activate SETTLE_DAO
            SETTLE_DAO -> DB: Insert settlementWindowStateChange
            activate DB
            hnote over DB #lightyellow
                settlementWindowStateChange
            end hnote
            SETTLE_DAO <-- DB: Return **settlementWindowStateChangeIdList**
            deactivate DB

            SETTLE_DAO -> SETTLE_DAO: Merge ids to prepare for single update command

            SETTLE_DAO -> DB: Update pointers to current state change ids
            activate DB
            hnote over DB #lightyellow
                UPDATE **settlementWindow**.currentStateChangeIds
            end hnote
            deactivate DB

            deactivate SETTLE_DAO
        end

        group Prepare and insert settlementStateChange
            opt settlementAccounts.settledCount != settlementAccountsInit.settledCount\n&& settlementAccounts.pendingSettlementCount == 0\n&& settlementAccounts.notSettledCount == 0
                note right of SSAPI #lightgray
                    settlementData.state = 'SETTLED'
                    settlementData.reason = 'All setlement accounts are settled'
                    settlementData.createdDate = currentTimestamp
                    settlementStateChange.push(settlementData)
                end note

                SSAPI -> SETTLE_DAO: Change settlement state\n<color #FF0000><b>Error code:</b> 2001</color>
                activate SETTLE_DAO
                SETTLE_DAO -> DB: Insert settlementStateChange
                activate DB
                hnote over DB #lightyellow
                    settlementStateChange
                end hnote
                SETTLE_DAO <-- DB: Return **settlementStateChangeId**
                deactivate DB

                SETTLE_DAO -> DB: Update pointer to current state change id
                activate DB
                hnote over DB #lightyellow
                    UPDATE **settlement**.currentStateChangeId
                end hnote
                deactivate DB
            end
        end
    end
    SSAPI -> SSAPI: <color FF0000>**Release DB lock**</color> on settlementParticipantCurrencyStateChange,\nsettlementWindowStateChange and settlementStateChange

    note left of SSAPI #lightgray
        Samples:
        "**settlementWindows**": [
            {
                "id": <integer>,
                "state": <enum>,
                "reason": <string>,
                "createdDate": <date>
            }
        ]
        "**participants**": [
            {
                "id": <integer>,
                "accounts": [
                    {
                        "id": <integer>,
                        "state": "SETTLED",
                        "reason": <string>,
                        "createdDate": <date>,
                        "netSettlementAmount": {
                            "amount": <decimal>,
                            "currency": <enum>
                        }
                    },
                    {
                        "id": <integer>,
                        "state": "PENDING_SETTLEMENT",
                        "reason": <string>,
                        "createdDate": <date>,
                        "netSettlementAmount": {
                            "amount": <decimal>,
                            "currency": <enum>
                        },
                        "errorInformation": {
                            "errorCode": <integer>,
                            "errorDescription": <string>
                        }
                    }
                ]
            }
        ]
    end note

    note left of SSAPI #lightyellow
        [
          {
            "id": {id},
            "state": settlementData.state,
            "createdDate": settlementData.createdDate,
            "settlementWindows": settlementWindows,
            "participants": participants
          }
        ]
    end note

    SSAPI -> OPERATOR: Return response
    deactivate SSAPI
end
@enduml
